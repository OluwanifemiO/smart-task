import { NextRequest, NextResponse } from 'next/server';import { GoogleGenerativeAI } from '@google/generative-ai';import { PrismaClient } from '@prisma/client';export async function POST(req: NextRequest) {    try {        const prisma = new PrismaClient();        // Initialize the Google Generative AI client        const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);        // 1. Get the user's input from the request body        const { prompt } = await req.json();        console.log('this is the prompt entered by the user: ' + prompt);        if (!prompt) {            return NextResponse.json({ error: 'Prompt is required' }, { status: 400 });        }        const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });        // 2. Craft the master prompt for Gemini        // This is the most important part! We're using "few-shot" prompting        // by giving it examples of what we want.        const masterPrompt = `      You are an expert task management assistant for an app called "SmartTask".      Your role is to parse a user's natural language input and convert it into a structured JSON object.      The JSON object must have the following fields: "title" (string), "description" (string, optional), "priorityLevel" (enum: "high", "medium", "low"), and "dueDate" (ISO 8601 string).      - The "title" should be a concise summary of the task.      - The "priorityLevel" should be inferred. If no priority is mentioned, default to "medium". Words like "urgent", "asap", "important" imply "high". Words like "later", "sometime", "if I have time" imply "low".      - The "dueDate" should be a valid ISO 8601 date-time string. Interpret relative dates like "tomorrow", "next Friday", "end of the month" based on the current date, which is ${new Date().toISOString()}. If no date is mentioned, the value should be set to the week after.      - The "description" should contain any extra details from the prompt that aren't in the title. If no extra details, make it an empty string.      Here are some examples:      User Input: "call the dentist tomorrow morning for a checkup"      JSON Output:      {        "title": "Call the dentist",        "description": "Call for a checkup.",        "priorityLevel": "medium",        "dueDate": "${new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0]}T09:00:00.000Z"      }      User Input: "finish the Q3 report by Friday EOD, it's a high priority"      JSON Output:      {        "title": "Finish the Q3 report",        "description": "Finish the Q3 report by Friday EOD.",        "priorityLevel": "high",        "dueDate": "YYYY-MM-DDTH17:00:00.000Z" // Replace with the actual date of the upcoming Friday      }      User Input: "buy groceries this weekend"      JSON Output:      {        "title": "Buy groceries",        "description": "",        "priorityLevel": "MEDIUM",        "dueDate": "YYYY-MM-DDTH12:00:00.000Z" // Replace with the actual date of the upcoming Saturday      }      User Input: "Maybe organize my desk sometime"      JSON Output:      {        "title": "Organize my desk",        "description": "",        "priorityLevel": "LOW",        "dueDate": "YYYY-MM-DDTH13:00:00.000Z" // Replace with the actual date of the next week as there was no due date specified      }      Now, parse the following user input. Return ONLY the JSON object, with no other text or explanations.      User Input: "${prompt}"      JSON Output:    `;        // 3. Call the Gemini API        const result = await model.generateContent(masterPrompt);        const response = await result.response;        console.log('this is the response from the model: ' + response);        const text = await response.text();        console.log('text response' + text);        // 4. Parse the AI's response and validate        let taskData;        try {            // The response might have markdown backticks, remove them            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();            taskData = JSON.parse(cleanedText);            console.log('this is the task data parsed: ' + taskData.toString());        } catch (error) {            console.error( 'Failed to parse JSON from Gemini:', text, error);            return NextResponse.json({ error: 'Failed to understand the task. Please try rephrasing.' }, { status: 500 });        }        // A simple validation        if (!taskData.title || !taskData.priorityLevel) {            return NextResponse.json({ error: 'AI response was missing required fields.' }, { status: 500 });        }        // 5. Save the new task to the database using Prisma        const newTask = await prisma.task.create({            data: {                title: taskData.title,                description: taskData.description,                // The type assertion is needed because Prisma's enum type is a string literal union                priorityLevel: taskData.priorityLevel.toLowerCase(),                // Convert string to Date object if it exists                dueDate: new Date(taskData.dueDate),                userId: 1,            },        });        // 6. Return the newly created task        console.log( newTask );        return NextResponse.json(newTask, { status: 201 });    } catch (error) {        console.error('Error in create-smart API:', error);        return NextResponse.json({ error: 'An internal server error occurred.' }, { status: 500 });    }}